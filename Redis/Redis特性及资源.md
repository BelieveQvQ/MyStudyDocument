# Redis 特性及资源



## 为什么要使用Redis



#### Redis都可以干什么事儿

缓存，毫无疑问这是 Redis 当今最为人熟知的使用场景，再提升服务器性能方面非常有效。

1. **排行榜**，如果使用传统的关系型数据库来做，非常麻烦，而利用 Redis 的 SortSet 数据结构能够非常方便搞定；

2. **计算器/限速器**，利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；

3. **好友关系**，利用集合的一些命令，比如求交集、并集、差集等，可以方便搞定一些共同好友、共同爱好之类的功能；

4. **简单消息队列**，除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；

5. **Session 共享**，以 PHP 为例，默认 Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。

   

------



#### Redis 不能干什么事儿

Redis 感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍，如果滥用可能导致系统的不稳定、成本增高等问题。

1. 比如，用 Redis 去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来 Redis 性能下降，因为持久化太过频繁会增大 Redis 服务的压力。
2. 简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。



------



#### 选择总需要找个理由

上面说了 Redis 的一些使用场景，那么这些场景的解决方案也有很多其它选择，比如缓存可以用 Memcache，Session共享还能用 MySql 来实现，消息队列可以用RabbitMQ，我们为什么一定要用 Redis 呢？

速度快，完全基于内存，使用 C 语言实现，网络层使用 epoll 解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；

**注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理。**

丰富的数据类型，Redis 有 8 种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这 5 种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；

除了提供的丰富的数据类型，Redis 还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo 等个性化功能。

Redis 的代码开源在 GitHub，代码非常简单优雅，任何人都能够吃透它的源码；它的编译安装也是非常的简单，没有任何的系统依赖；有非常活跃的社区，各种客户端的语言支持也是非常完善。另外它还支持事务（没用过）、持久化、主从复制让高可用、分布式成为可能。

做为一个开发者，对于我们使用的东西不能让它成为一个黑盒子，我们应该深入进去，对它更了解、更熟悉，今天简单说了下 Redis 的使用场景，以及为什么选择了 Redis 而不是其他。



------



## 命令手册:

https://www.redis.com.cn/commands.html



------



## 中文文档:

https://www.redis.com.cn/documentation.html



------



## 模块:

模块是4.0出现的改动点，可以通过外部模块对Redis进行功能性扩展。 Redis的模块采用的是**动态链接库**的方式，可以启动的时候加载，也可以在运行时加载（MODULE LOAD）,在Linux系统里面，可以通过dlopen，dlsym等实现动态加载库，在业务系统里面，经常用于将业务代码和框架代码进行分离，以实现插件化开发。在Redis里面也是同样的道理。要实现分离，首先需要的是初始化，以便让框架可以找到对应的方法，这就需要进行注册，Redis通过RedisModule_Init方法进行注册模块，和RedisModule_CreateCommand注册自定义方法。

Redis导出了redismodule.h头文件，通过实现该头文件相关API函数，然后编译为so动态库即可，可以在配置文件中使用loadmodule指明，也可以在运行时使用命令动态加载（MODULE LOAD）。

Redis 模块列表，适用于 redis v4.0 或更高版本，以 Github stars 数量排序。此列表包含两组模块：OSI许可证下的模块和某些专有许可证下的模块。非OSI模块被明确标记为非开源。

https://www.redis.com.cn/modules.html

